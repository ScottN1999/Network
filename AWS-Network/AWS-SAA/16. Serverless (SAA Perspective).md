# AWS Lambda

Easy pricing 
- Pay per request and compute time
- Free tier of 1 million Lambda requests and 400,000 GBs of compute time

It is integrated with the whole suite of AWS services - as well with many programming languages.

Easy monitoring through CloudWatch - easy to get more resources per functions (up to 10GB of RAM), increasing RAM will also improve CPU and network!

## Lambda Limits 

**Per-region**

**Execution**

- Memory allocation : 128 MB - 10GB (1 MB increments)
- Maximum execution time: 15 minutes
- Environment variables: 4kb
- Disk cap in the "function container" (in /tmp): 512MB to 10GB
- Concurrency executions: 1000 (can be increased)

**Deployment:**

- Lambda function deployment size (compressed .zip): 50 MB
- Size of uncompressed deployment (code + dependencies): 250 MB
- Can use the /tmp directory to load other files at startup
- Size of environment variables: 4KB

## Lambda SnapStart

Improve your Lambda functions performance up to 10x at no extra cost for Java 11 and above.

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/63dc6948-240b-4c11-a2a7-a6d640e98034)

When it's enabled, function is invoked from a pre-intialized state (no function initialization from scratch)

When you publish a new version:
- Lambda initalizes your function
- Takes a snapshot of memory and disk state of the initialized function
- Snapshot is cached for low-latency access

## Lambda@Edge & CloudFront Functions

Many modern applications execute some form of the logic at the edge

**Edge function:**
- A code that you write and attach to the CloudFront distributions
- Runs close to your users to minimize latency

CloudFront provides two types: **CloudFront Functions and Lambda@Edge**, you don't have to manage any servers, deployed globally

Use case: Customize the CDN content
  - Website Security and Privacy
  - Dynamic Web app at the edge
  - Search Engine Optimization (SEO)
  - Intelligently Route Across Orgins and Data Centers
  - Bot mitigation at the edge
  - Real-time image transformation
  - A/B Testing
  - User authentication and authorization
  - User prioritization
  - User tacking and analytics

Pay only what you use

**CloudFront Functions**

Typical CloudFront communications:

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/1ef94e8b-6ac6-4549-a349-f50a02d1794f)

CloudFront Functions are lightweight functions written in JS - it's for high-scale, latency sensitive CDN customizations. Sub-ms startup times, millions requests/second

Used to change Viewer requests and responses:
**- Viewer Request:** After CloufFront receives a request from a viewer
**- Viewer Response:** Before CF forward the response to the viewer

Native feature of CF

**Lambda@Edge**

Lambda functions written in NodeJS or Python
Scales up to 1000s of requests/second

Used to change CF requests and responses:
- Viewer request - after CF receives a request from a viewer
- Origin Request - Before CF forward the request to the origin
- Origin Response - After CF receives the response from the origin
- Viewer Response - before CF forwards the response to the viewer

Author your functions on AWS Region, the CF replicates to its locations

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/d601149e-2336-4844-ae57-62b1f2580814)


![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/df33da4a-2dfa-4364-92e9-878873a280c2)


## Lambda in VPC

Lambda by default is launched in an AWS-owned VPC - therefore outside your VPC and won't work with any services within the VPC.

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/f8500110-1055-4d95-9694-2b246892c2c4)

We can launch Lambda in a VPC to fix this - You must define the VPC ID, the subnets and NSG. Lambda then will create an ENI in your subnets

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/50f5a65d-7af0-45f6-855e-33831603086f)

## Lambda with RDS Proxy

If Lambda functions directly access your DB, they may open too many connections under high load

RDS Proxy
- Improve scalability by pooling and sharing DB connections
- Improve availability by reducing by 66% the failover time and preserving connections
- Improve security by enforcing IAM auth and storing creds in Secrets Manager

**The Lambda functions must be deployed in your VPC, because RDS Proxy is never publicly accessible**

## Invoking Lambda from RDS and Aurora
Allows you to process **data events** from within a DB

Supported for **RDS for PostgreSQL and AUrora MySQL**

**Must allow outbound traffic to your Lambda function** from within your DB instance ( Public, NAT GW, VPC Endpoints)

**DB instance must have the required perms to invoke the Lambda function (lambda resource-based Policy and IAM Policy)**

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/9897155e-1de6-416c-8edb-6a8961bd9f5d)

# AWS DynamoDB

Fully managed DB, highly available with replication across multiple AZs. NoSQL DB - not a relational DB - with transaction support.

Scales to massive workloads, distrubuted database.

Millions of requests per seconds, trillions of row, 100s of TB of storage - fast and consistent in performance (single-digit millisecond).

Integrated with IAM for sec, authorization, and administration.

Low cost and auto-scaling capabilities, no maintenance or patching, always available.

2 Table classes:
- Standard
- IA

DynamoDB is made of **tables**

Each table has a **Primary Key**, each table have an infinite number of items (=rows), each table has attributes) can be added over time - can be null).

Max size of an item is 400kb

Data types supported are:
- Scalar Types: String, number, binary, boolean, Null
- Document types - List, Map
- Set types - String set, number set, binary set

**IMPORTANT TO KNOW FOR EXAM - DYNAMODB IS GOOD FOR RAPIDLY EVOLVING SCHEMAS**

![image](https://github.com/UpheldSmile/Virtual-Network/assets/49825639/e8990e6f-21e0-4084-9ee4-d399f3be5a11)

**Managing capacitiy:**

Read/Write capacity modes:

**Provisioned Mode (default)**
- You specify the number of reads/writes per second
- You need to plan cap beforehand
- Pay for **provisioned** Read Capacity Units (RCU) and Write Capacity Units (WCU)
- Possibility to add **auto-scaling** mode for RCU and WCU
- Is good for predictable load, and for cost-saving

**On-demand mode**
- Read/writes automatically scale up and down with your workloads
- No cap planning needed
- Pay for what you use, more expensive
- Great for **unpredictable** workloads, **steep sudden spikes**
